
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../exploration/boxsearch/">
      
      
        <link rel="next" href="../parameters/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.6">
    
    
      
        <title>Models - Neurolib</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.558e4712.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../css/ansi-colours.css">
    
      <link rel="stylesheet" href="../../css/jupyter-cells.css">
    
      <link rel="stylesheet" href="../../css/pandas-dataframe.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#models" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Neurolib" class="md-header__button md-logo" aria-label="Neurolib" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Neurolib
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Models
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/neurolib-dev/neurolib" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    neurolib-dev/neurolib
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Neurolib" class="md-nav__button md-logo" aria-label="Neurolib" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Neurolib
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/neurolib-dev/neurolib" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    neurolib-dev/neurolib
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Introduction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/" class="md-nav__link">
        Contributing to neurolib
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3" tabindex="0" aria-expanded="false">
          Examples
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Examples" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Examples
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0-aln-minimal/" class="md-nav__link">
        Example 0 aln minimal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.1-hopf-minimal/" class="md-nav__link">
        Example 0.1 hopf minimal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.2-basic_analysis/" class="md-nav__link">
        Example 0.2 basic analysis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.3-fhn-minimal/" class="md-nav__link">
        Example 0.3 fhn minimal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.4-wc-minimal/" class="md-nav__link">
        Example 0.4 wc minimal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.5-external-stimulus/" class="md-nav__link">
        Example 0.5 external stimulus
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-0.6-custom-model/" class="md-nav__link">
        Example 0.6 custom model
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-1-aln-parameter-exploration/" class="md-nav__link">
        Example 1 aln parameter exploration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-1.1-custom-parameter-exploration/" class="md-nav__link">
        Example 1.1 custom parameter exploration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-1.2-brain-network-exploration/" class="md-nav__link">
        Example 1.2 brain network exploration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-1.2.1-brain-exploration-postprocessing/" class="md-nav__link">
        Example 1.2.1 brain exploration postprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-1.3-aln-bifurcation-diagram/" class="md-nav__link">
        Example 1.3 aln bifurcation diagram
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-2-evolutionary-optimization-minimal/" class="md-nav__link">
        Example 2 evolutionary optimization minimal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-2.0.1-save-and-load-evolution/" class="md-nav__link">
        Example 2.0.1 save and load evolution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-2.1-evolutionary-optimization-aln/" class="md-nav__link">
        Example 2.1 evolutionary optimization aln
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-2.2-evolution-brain-network-aln-resting-state-fit/" class="md-nav__link">
        Example 2.2 evolution brain network aln resting state fit
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-3-meg-functional-connectivity/" class="md-nav__link">
        Example 3 meg functional connectivity
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-4-multimodel-intro/" class="md-nav__link">
        Example 4 multimodel intro
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-4.1-multimodel-custom-model/" class="md-nav__link">
        Example 4.1 multimodel custom model
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/example-4.2-multimodel-backends-and-optimization/" class="md-nav__link">
        Example 4.2 multimodel backends and optimization
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4" tabindex="0" aria-expanded="false">
          Exploration
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Exploration" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Exploration
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exploration/boxsearch/" class="md-nav__link">
        BoxSearch
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_5" type="checkbox" id="__nav_5" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5" tabindex="0" aria-expanded="true">
          Models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Models" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Models
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Models
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#loading-a-model" class="md-nav__link">
    Loading a model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-base-class-methods" class="md-nav__link">
    Model base class methods
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model" class="md-nav__link">
    neurolib.models.model.Model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.output" class="md-nav__link">
    output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.__getitem__" class="md-nav__link">
    __getitem__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.autochunk" class="md-nav__link">
    autochunk()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.checkChunkwise" class="md-nav__link">
    checkChunkwise()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.clearModelState" class="md-nav__link">
    clearModelState()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getMaxDelay" class="md-nav__link">
    getMaxDelay()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getOutput" class="md-nav__link">
    getOutput()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getOutputs" class="md-nav__link">
    getOutputs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.initializeBold" class="md-nav__link">
    initializeBold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.initializeRun" class="md-nav__link">
    initializeRun()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.integrate" class="md-nav__link">
    integrate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.integrateChunkwise" class="md-nav__link">
    integrateChunkwise()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.randomICs" class="md-nav__link">
    randomICs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.run" class="md-nav__link">
    run()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setInitialValuesToLastState" class="md-nav__link">
    setInitialValuesToLastState()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setInputs" class="md-nav__link">
    setInputs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setOutput" class="md-nav__link">
    setOutput()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setSamplingDt" class="md-nav__link">
    setSamplingDt()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setStateVariables" class="md-nav__link">
    setStateVariables()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.simulateBold" class="md-nav__link">
    simulateBold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.storeOutputsAndStates" class="md-nav__link">
    storeOutputsAndStates()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.xr" class="md-nav__link">
    xr()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../parameters/" class="md-nav__link">
        Parameters
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" tabindex="0" aria-expanded="false">
          Optimization
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Optimization" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Optimization
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../optimization/evolution/" class="md-nav__link">
        Evolution
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" tabindex="0" aria-expanded="false">
          Utils
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Utils" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Utils
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/dataset/" class="md-nav__link">
        Dataset
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/parameterspace/" class="md-nav__link">
        ParameterSpace
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/signal/" class="md-nav__link">
        Signal
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/stimulus/" class="md-nav__link">
        Stimulus
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#loading-a-model" class="md-nav__link">
    Loading a model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-base-class-methods" class="md-nav__link">
    Model base class methods
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model" class="md-nav__link">
    neurolib.models.model.Model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.output" class="md-nav__link">
    output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.__getitem__" class="md-nav__link">
    __getitem__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.autochunk" class="md-nav__link">
    autochunk()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.checkChunkwise" class="md-nav__link">
    checkChunkwise()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.clearModelState" class="md-nav__link">
    clearModelState()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getMaxDelay" class="md-nav__link">
    getMaxDelay()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getOutput" class="md-nav__link">
    getOutput()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.getOutputs" class="md-nav__link">
    getOutputs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.initializeBold" class="md-nav__link">
    initializeBold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.initializeRun" class="md-nav__link">
    initializeRun()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.integrate" class="md-nav__link">
    integrate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.integrateChunkwise" class="md-nav__link">
    integrateChunkwise()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.randomICs" class="md-nav__link">
    randomICs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.run" class="md-nav__link">
    run()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setInitialValuesToLastState" class="md-nav__link">
    setInitialValuesToLastState()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setInputs" class="md-nav__link">
    setInputs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setOutput" class="md-nav__link">
    setOutput()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setSamplingDt" class="md-nav__link">
    setSamplingDt()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.setStateVariables" class="md-nav__link">
    setStateVariables()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.simulateBold" class="md-nav__link">
    simulateBold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.storeOutputsAndStates" class="md-nav__link">
    storeOutputsAndStates()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neurolib.models.model.Model.xr" class="md-nav__link">
    xr()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  



<h1 id="models">Models</h1>
<p>Models are the core of <code>neurolib</code>. The <code>Model</code> superclass will help you to load, simulate, and analyse models. It also makes it very easy to implement your own neural mass model (see <a href="/examples/example-0.6-custom-model/">Example 0.6 custom model</a>).</p>
<h2 id="loading-a-model">Loading a model</h2>
<p>To load a model, we need to import the submodule of a model and instantiate it. This example shows how to load a single node of the <code>ALNModel</code>. See <a href="/examples/example-0-aln-minimal/">Example 0 aln minimal</a> on how to simulate a whole-brain network using this model.</p>
<div class="highlight"><pre><span></span><code>from neurolib.models.aln import ALNModel # Import the model
model = ALNModel() # Create an instance
model.run() # Run it
</code></pre></div>
<h2 id="model-base-class-methods">Model base class methods</h2>


<div class="doc doc-object doc-class">


<a id="neurolib.models.model.Model"></a>
  <div class="doc doc-contents first">

  
      <p>The Model base class runs models, manages their outputs, parameters and more.
This class should serve as the base class for all implemented models.</p>


        <details class="quote">
          <summary>Source code in <code>neurolib/models/model.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Model base class runs models, manages their outputs, parameters and more.</span>
<span class="sd">    This class should serve as the base class for all implemented models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integration</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Model name is not a string.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Noname&quot;</span>

        <span class="k">assert</span> <span class="n">integration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Model integration function not given.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integration</span> <span class="o">=</span> <span class="n">integration</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Parameters must be a dictionary.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># assert self.state_vars not None:</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;state_vars&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has no attribute `state_vars`, which should be alist of strings containing all variable names.&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">]),</span> <span class="s2">&quot;All entries in state_vars must be strings.&quot;</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;default_output&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> needs to define a default output variable in `default_output`.&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_output</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`default_output` must be a string.&quot;</span>

        <span class="c1"># if no output_vars is set, it will be replaced by state_vars</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;output_vars&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span>

        <span class="c1"># create output and state dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxDelay</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeRun</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: Model initialized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initializeBold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize BOLD model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># function to transform model state before passing it to the bold model</span>
        <span class="c1"># Note: This can be used like the parameter \epsilon in Friston2000</span>
        <span class="c1"># (neural efficacy) by multiplying the input with a constant via</span>
        <span class="c1"># self.boldInputTransform = lambda x: x * epsilon</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;boldInputTransform&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span> <span class="o">=</span> <span class="n">bold</span><span class="o">.</span><span class="n">BOLDModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># logging.info(f&quot;{self.name}: BOLD model initialized.&quot;)</span>

    <span class="k">def</span> <span class="nf">simulateBold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the default output of the model and simulates the BOLD model.</span>
<span class="sd">        Adds the simulated BOLD signal to outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
            <span class="c1"># first we loop through all state variables</span>
            <span class="k">for</span> <span class="n">svn</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
                <span class="c1"># the default output is used as the input for the bold model</span>
                <span class="k">if</span> <span class="n">svn</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_output</span><span class="p">:</span>
                    <span class="n">bold_input</span> <span class="o">=</span> <span class="n">sv</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
                    <span class="c1"># logging.debug(f&quot;BOLD input `{svn}` of shape {bold_input.shape}&quot;)</span>
                    <span class="k">if</span> <span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="p">:</span>
                        <span class="c1"># only if the length of the output has a zero mod to the sampling rate,</span>
                        <span class="c1"># the downsampled output from the boldModel can correctly appended to previous data</span>
                        <span class="c1"># so: we are lazy here and simply disable appending in that case ...</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Output size </span><span class="si">{</span><span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a multiple of BOLD sampling length </span><span class="si">{</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="si">}</span><span class="s2">, will not append data.&quot;</span>
                            <span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulating BOLD: boldModel.run(append=</span><span class="si">{</span><span class="n">append</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                        <span class="c1"># transform bold input according to self.boldInputTransform</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span><span class="p">:</span>
                            <span class="n">bold_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span><span class="p">(</span><span class="n">bold_input</span><span class="p">)</span>

                        <span class="c1"># simulate bold model</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">bold_input</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>

                        <span class="n">t_BOLD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">t_BOLD</span>
                        <span class="n">BOLD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">BOLD</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;BOLD.t_BOLD&quot;</span><span class="p">,</span> <span class="n">t_BOLD</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;BOLD.BOLD&quot;</span><span class="p">,</span> <span class="n">BOLD</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Will not simulate BOLD if output </span><span class="si">{</span><span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> not at least of duration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;BOLD model not initialized, not simulating BOLD. Use `run(bold=True)`&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkChunkwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the model fulfills requirements for chunkwise simulation.</span>
<span class="sd">        Checks whether the sampling rate for outputs fits to chunksize and duration.</span>
<span class="sd">        Throws errors if not.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;State variable names not given.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Initial value variable names not given.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">),</span> <span class="s2">&quot;State variables are not same length as initial values.&quot;</span>

        <span class="c1"># throw a warning if the user is nasty</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span> <span class="o">%</span> <span class="n">chunksize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;It is strongly advised to use a `chunksize` (</span><span class="si">{</span><span class="n">chunksize</span><span class="si">}</span><span class="s2">) that is a divisor of `duration / dt` (</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

        <span class="c1"># if `sampling_dt` is set, do some checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># sample_dt checks are required after setting chunksize</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
            <span class="p">),</span> <span class="s2">&quot;`chunksize * dt` must be &gt;= `sampling_dt`&quot;</span>

            <span class="c1"># ugly floating point modulo hack: instead of float1%float2==0, we do</span>
            <span class="c1"># (float1/float2)%1==0</span>
            <span class="k">assert</span> <span class="p">((</span><span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Chunksize </span><span class="si">{</span><span class="n">chunksize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> must be divisible by sampling dt &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Last chunk of size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">chunksize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> must be divisible by sampling dt &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">setSamplingDt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if sampling_dt is set correctly and sets self.`sample_every`</span>
<span class="sd">        1) Check if sampling_dt is multiple of dt</span>
<span class="sd">        2) Check if semplind_dt is greater than duration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="s2">&quot;`sampling_dt` needs to be &gt;= `dt`&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
            <span class="p">),</span> <span class="s2">&quot;`sampling_dt` needs to be lower than `duration`&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t handle `sampling_dt`=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initializeRun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initializeBold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization before each run.</span>

<span class="sd">        :param initializeBold: initialize BOLD model</span>
<span class="sd">        :type initializeBold: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the maxDelay of the system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxDelay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxDelay</span><span class="p">()</span>

        <span class="c1"># length of the initial condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDelay</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># check dt / sampling_dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setSamplingDt</span><span class="p">()</span>

        <span class="c1"># force bold if params[&#39;bold&#39;] == True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
            <span class="n">initializeBold</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># set up the bold model, if it didn&#39;t happen yet</span>
        <span class="k">if</span> <span class="n">initializeBold</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializeBold</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunkwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">append_outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">continue_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main interfacing function to run a model.</span>

<span class="sd">        The model can be run in three different ways:</span>
<span class="sd">        1) `model.run()` starts a new run.</span>
<span class="sd">        2) `model.run(chunkwise=True)` runs the simulation in chunks of length `chunksize`.</span>
<span class="sd">        3) `mode.run(continue_run=True)` continues the simulation of a previous run.</span>

<span class="sd">        :param inputs: list of inputs to the model, must have the same order as model.input_vars. Note: no sanity check is performed for performance reasons. Take care of the inputs yourself.</span>
<span class="sd">        :type inputs: list[np.ndarray|]</span>
<span class="sd">        :param chunkwise: simulate model chunkwise or in one single run, defaults to False</span>
<span class="sd">        :type chunkwise: bool, optional</span>
<span class="sd">        :param chunksize: size of the chunk to simulate in dt, if set will imply chunkwise=True, defaults to 2s</span>
<span class="sd">        :type chunksize: int, optional</span>
<span class="sd">        :param bold: simulate BOLD signal (only for chunkwise integration), defaults to False</span>
<span class="sd">        :type bold: bool, optional</span>
<span class="sd">        :param append: append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</span>
<span class="sd">        :type append: bool, optional</span>
<span class="sd">        :param continue_run: continue a simulation by using the initial values from a previous simulation</span>
<span class="sd">        :type continue_run: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: legacy argument support</span>
        <span class="k">if</span> <span class="n">append_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="n">append_outputs</span>

        <span class="c1"># if a previous run is not to be continued clear the model&#39;s state</span>
        <span class="k">if</span> <span class="n">continue_run</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clearModelState</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initializeRun</span><span class="p">(</span><span class="n">initializeBold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>

        <span class="c1"># enable chunkwise if chunksize is set</span>
        <span class="n">chunkwise</span> <span class="o">=</span> <span class="n">chunkwise</span> <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">chunkwise</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">append_outputs</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">continue_run</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setInitialValuesToLastState</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>

            <span class="c1"># check if model is safe for chunkwise integration</span>
            <span class="c1"># and whether sampling_dt is compatible with duration and chunksize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checkChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bold</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: BOLD model not initialized, not simulating BOLD. Use `run(bold=True)`&quot;</span><span class="p">)</span>
                <span class="n">bold</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrateChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="n">bold</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>

        <span class="c1"># check if there was a problem with the simulated data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkOutputs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">checkOutputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check nans in output</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;nan in model output!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EXPLOSION_THRESHOLD</span> <span class="o">=</span> <span class="mf">1e20</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="n">EXPLOSION_THRESHOLD</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;nan in model output!&quot;</span><span class="p">)</span>

        <span class="c1"># check nans in BOLD</span>
        <span class="k">if</span> <span class="s2">&quot;BOLD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">BOLD</span><span class="o">.</span><span class="n">BOLD</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;nan in BOLD output!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls each models `integration` function and saves the state and the outputs of the model.</span>

<span class="sd">        :param append: append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</span>
<span class="sd">        :type append: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># run integration</span>
        <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storeOutputsAndStates</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">)</span>

        <span class="c1"># force bold if params[&#39;bold&#39;] == True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
            <span class="n">simulate_bold</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># bold simulation after integration</span>
        <span class="k">if</span> <span class="n">simulate_bold</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simulateBold</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrateChunkwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repeatedly calls the chunkwise integration for the whole duration of the simulation.</span>
<span class="sd">        If `bold==True`, the BOLD model is simulated after each chunk.</span>

<span class="sd">        :param chunksize: size of each chunk to simulate in units of dt</span>
<span class="sd">        :type chunksize: int</span>
<span class="sd">        :param bold: simulate BOLD model after each chunk, defaults to False</span>
<span class="sd">        :type bold: bool, optional</span>
<span class="sd">        :param append_outputs: append the chunkwise outputs to the outputs attribute, defaults to False</span>
<span class="sd">        :type append_outputs: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">totalDuration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
        <span class="c1"># create a shallow copy of the parameters</span>
        <span class="n">lastT</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">totalDuration</span> <span class="o">-</span> <span class="n">lastT</span> <span class="o">&gt;=</span> <span class="n">dt</span> <span class="o">-</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="c1"># Determine the size of the next chunk</span>
            <span class="c1"># account for floating point errors</span>
            <span class="n">remainingChunkSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">totalDuration</span> <span class="o">-</span> <span class="n">lastT</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
            <span class="n">currentChunkSize</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">remainingChunkSize</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">autochunk</span><span class="p">(</span><span class="n">chunksize</span><span class="o">=</span><span class="n">currentChunkSize</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>
            <span class="c1"># we save the last simulated time step</span>
            <span class="n">lastT</span> <span class="o">+=</span> <span class="n">currentChunkSize</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="c1"># or</span>
            <span class="c1"># lastT = self.state[&quot;t&quot;][-1]</span>

        <span class="c1"># set duration back to its original value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalDuration</span>

    <span class="k">def</span> <span class="nf">clearModelState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clears the model&#39;s state to create a fresh one&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
        <span class="c1"># reinitialize bold model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializeBold</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">storeOutputsAndStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes the simulated variables of the integration and stores it to the appropriate model output and state object.</span>

<span class="sd">        :param t: time vector</span>
<span class="sd">        :type t: list</span>
<span class="sd">        :param variables: variable from time integration</span>
<span class="sd">        :type variables: numpy.ndarray</span>
<span class="sd">        :param append: append output to existing output or overwrite, defaults to False</span>
<span class="sd">        :type append: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># save time array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setStateVariables</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="c1"># save outputs</span>
        <span class="k">for</span> <span class="n">svn</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">svn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">svn</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setStateVariables</span><span class="p">(</span><span class="n">svn</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setInitialValuesToLastState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the last state of the model and sets the initial conditions to that state for continuing a simulation.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">):</span>
            <span class="c1"># if state variables are one-dimensional (in space only)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span>
            <span class="c1"># if they are space-time arrays</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we set the next initial condition to the last state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">][:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">randomICs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a new set of uniformly-distributed random initial conditions for the model.</span>

<span class="sd">        TODO: All parameters are drawn from the same distribution / range. Allow for independent ranges.</span>

<span class="sd">        :param min: Minium of uniform distribution</span>
<span class="sd">        :type min: float</span>
<span class="sd">        :param max: Maximum of uniform distribution</span>
<span class="sd">        :type max: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">setInputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take inputs from a list and store it in the appropriate model parameter for external input.</span>
<span class="sd">        TODO: This is not safe yet, checks should be implemented whether the model has inputs defined or not for example.</span>

<span class="sd">        :param inputs: list of inputs</span>
<span class="sd">        :type inputs: list[np.ndarray(), ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">autochunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Executes a single chunk of integration, either for a given duration</span>
<span class="sd">        or a single timestep `dt`. Gathers all inputs to the model and resets</span>
<span class="sd">        the initial conditions as a preparation for the next chunk.</span>

<span class="sd">        :param inputs: list of input values, ordered according to self.input_vars, defaults to None</span>
<span class="sd">        :type inputs: list[np.ndarray|], optional</span>
<span class="sd">        :param chunksize: length of a chunk to simulate in dt, defaults 1</span>
<span class="sd">        :type chunksize: int, optional</span>
<span class="sd">        :param append_outputs: append the chunkwise outputs to the outputs attribute, defaults to False</span>
<span class="sd">        :type append_outputs: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the duration for this chunk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>

        <span class="c1"># set inputs</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setInputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># run integration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">append_outputs</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>

        <span class="c1"># set initial conditions to last state for the next chunk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setInitialValuesToLastState</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getMaxDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the maximum delay of the model. This function should be overloaded</span>
<span class="sd">        if the model has internal delays (additional to delay between nodes defined by Dmat)</span>
<span class="sd">        such as the delay between an excitatory and inhibitory population within each brain area.</span>
<span class="sd">        If this function is not overloaded, the maximum delay is assumed to be defined from the</span>
<span class="sd">        global delay matrix `Dmat`.</span>

<span class="sd">        Note: Maxmimum delay is given in units of dt.</span>

<span class="sd">        :return: maxmimum delay of the model in units of dt</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">)</span>
        <span class="n">Dmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lengthMat&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Dmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># divide Dmat by signalV</span>
            <span class="n">signalV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;signalV&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">signalV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Dmat</span> <span class="o">=</span> <span class="n">Dmat</span> <span class="o">/</span> <span class="n">signalV</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if signalV is 0, eliminate delays</span>
                <span class="n">Dmat</span> <span class="o">=</span> <span class="n">Dmat</span> <span class="o">*</span> <span class="mf">0.0</span>

        <span class="c1"># only if Dmat and dt exist, a global max delay can be computed</span>
        <span class="k">if</span> <span class="n">Dmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Dmat_ndt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">Dmat</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># delay matrix in multiples of dt</span>
            <span class="n">max_global_delay</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">Dmat_ndt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_global_delay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">max_global_delay</span>

    <span class="k">def</span> <span class="nf">setStateVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the models current state variables.</span>

<span class="sd">        TODO: Cut state variables to length of self.maxDelay</span>
<span class="sd">        However, this could be time-memory tradeoff</span>

<span class="sd">        :param name: name of the state variable</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: value of the variable</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># old</span>
        <span class="c1"># self.state[name] = data.copy()</span>

        <span class="c1"># if the data is temporal, cut off initial values</span>
        <span class="c1"># NOTE: this shuold actually check for</span>
        <span class="c1"># if data.shape[1] &gt; 1:</span>
        <span class="c1"># else: data.copy()</span>
        <span class="c1"># there coulb be (N, 1)-dimensional output, right now</span>
        <span class="c1"># it is requred to be of shape (N, )</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds an output to the model, typically a simulation result.</span>
<span class="sd">        :params name: Name of the output in dot.notation, a la &quot;outputgroup.output&quot;</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :params data: Output data, can&#39;t be a dictionary!</span>
<span class="sd">        :type data: `numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Output data cannot be a dictionary.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Output name must be a string.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;Output must be a `numpy.ndarray`.&quot;</span>

        <span class="c1"># remove initial conditions from output</span>
        <span class="k">if</span> <span class="n">removeICs</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to truncate data of shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># subsample to sampling dt</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">::</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to subsample data of shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># if the output is a single name (not dot.separated)</span>
        <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="c1"># append data</span>
            <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># special treatment for time data:</span>
                <span class="c1"># increment the time by the last recorded duration</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># save all data into output dict</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="c1"># set output as an attribute</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># build results dictionary and write into self.outputs</span>
            <span class="c1"># dot.notation iteration</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>  <span class="c1"># not copy, reference!</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="c1"># if it&#39;s the last iteration, store data</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># TODO: this needs to be append-aware like above</span>
                    <span class="c1"># if append:</span>
                    <span class="c1">#     if k == &quot;t&quot;:</span>
                    <span class="c1">#         data += level[k][-1]</span>
                    <span class="c1">#     level[k] = np.hstack((level[k], data))</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     level[k] = data</span>
                    <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="c1"># if key is in outputs, then go deeper</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
                <span class="c1"># if it&#39;s a new key, create new nested dictionary, set attribute, then go deeper</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an output of a given name (dot.semarated)</span>
<span class="sd">        :param name: A key, grouped outputs in the form group.subgroup.variable</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :returns: Output data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Output name must be a string.&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">lastOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lastOutput</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not found in outputs.&quot;</span>
            <span class="n">lastOutput</span> <span class="o">=</span> <span class="n">lastOutput</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lastOutput</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index outputs with a dictionary-like key, e.g., `model[&#39;rates_exc&#39;]`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutput</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getOutputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all outputs of an output group. Examples: `getOutputs(&quot;BOLD&quot;)` or simply `getOutputs()`</span>

<span class="sd">        :param group: Group name, subgroups separated by dots. If left empty (default), all outputs of the root group</span>
<span class="sd">            are returned.</span>
<span class="sd">        :type group: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Group name must be a string.&quot;</span>

        <span class="k">def</span> <span class="nf">filterOutputsFromGroupDict</span><span class="p">(</span><span class="n">groupDict</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Return a dictionary with the output data of a group disregarding all other nested dicts.</span>
<span class="sd">            :param groupDict: Dictionary of outputs (can include other groups)</span>
<span class="sd">            :type groupDict: dict</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Not a dictionary.&quot;</span>
            <span class="c1"># make a deep copy of the dictionary</span>
            <span class="n">returnDict</span> <span class="o">=</span> <span class="n">groupDict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">groupDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">returnDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">returnDict</span>

        <span class="c1"># if a group deeper than the root is given, select the last node</span>
        <span class="n">lastOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lastOutput</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not found in outputs.&quot;</span>
                <span class="n">lastOutput</span> <span class="o">=</span> <span class="n">lastOutput</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lastOutput</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> does not refer to a group.&quot;</span>
        <span class="c1"># filter out all output *groups* that might be in this node and return only output data</span>
        <span class="k">return</span> <span class="n">filterOutputsFromGroupDict</span><span class="p">(</span><span class="n">lastOutput</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns value of default output as defined by `self.default_output`.</span>
<span class="sd">        Note that all outputs are saved in the attribute `self.outputs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Default output has not been set yet. Use `setDefaultOutput()`.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a group of outputs to xarray. Output group needs to contain an</span>
<span class="sd">        element that starts with the letter &quot;t&quot; or it will not recognize any time axis.</span>

<span class="sd">        :param group: Output group name, example:  &quot;BOLD&quot;. Leave empty for top group.</span>
<span class="sd">        :type group: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Group name must be a string.&quot;</span>
        <span class="c1"># take all outputs of one group: disregard all dictionaries because they are subgroups</span>
        <span class="n">outputDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutputs</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="c1"># make sure that there is a time array</span>
        <span class="n">timeDictKey</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="p">:</span>
            <span class="n">timeDictKey</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">):</span>
                    <span class="n">timeDictKey</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assuming </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> to be the time axis.&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">timeDictKey</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;No time array found (starting with t) in output group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">outputDict</span><span class="p">[</span><span class="n">timeDictKey</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">outputDict</span><span class="p">[</span><span class="n">timeDictKey</span><span class="p">]</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">outputNames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">outputNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">nNodes</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nNodes</span><span class="p">))</span>
        <span class="n">allOutputsStacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>  <span class="c1"># What? Where? When?</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">allOutputsStacked</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">outputNames</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="s2">&quot;space&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.output">
<code class="highlight language-python"><span class="n">output</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns value of default output as defined by <code>self.default_output</code>.
Note that all outputs are saved in the attribute <code>self.outputs</code>.</p>
  </div>

</div>



<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.__getitem__">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Index outputs with a dictionary-like key, e.g., <code>model['rates_exc']</code>.</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Index outputs with a dictionary-like key, e.g., `model[&#39;rates_exc&#39;]`.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutput</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.autochunk">
<code class="highlight language-python"><span class="n">autochunk</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Executes a single chunk of integration, either for a given duration
or a single timestep <code>dt</code>. Gathers all inputs to the model and resets
the initial conditions as a preparation for the next chunk.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code>list[np.ndarray|], optional</code>
          </td>
          <td><p>list of input values, ordered according to self.input_vars, defaults to None</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>chunksize</code></td>
          <td>
                <code>int, optional</code>
          </td>
          <td><p>length of a chunk to simulate in dt, defaults 1</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
        <tr>
          <td><code>append_outputs</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>append the chunkwise outputs to the outputs attribute, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">autochunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Executes a single chunk of integration, either for a given duration</span>
<span class="sd">    or a single timestep `dt`. Gathers all inputs to the model and resets</span>
<span class="sd">    the initial conditions as a preparation for the next chunk.</span>

<span class="sd">    :param inputs: list of input values, ordered according to self.input_vars, defaults to None</span>
<span class="sd">    :type inputs: list[np.ndarray|], optional</span>
<span class="sd">    :param chunksize: length of a chunk to simulate in dt, defaults 1</span>
<span class="sd">    :type chunksize: int, optional</span>
<span class="sd">    :param append_outputs: append the chunkwise outputs to the outputs attribute, defaults to False</span>
<span class="sd">    :type append_outputs: bool, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># set the duration for this chunk</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>

    <span class="c1"># set inputs</span>
    <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setInputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="c1"># run integration</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">append_outputs</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>

    <span class="c1"># set initial conditions to last state for the next chunk</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setInitialValuesToLastState</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.checkChunkwise">
<code class="highlight language-python"><span class="n">checkChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Checks if the model fulfills requirements for chunkwise simulation.
Checks whether the sampling rate for outputs fits to chunksize and duration.
Throws errors if not.</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">checkChunkwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks if the model fulfills requirements for chunkwise simulation.</span>
<span class="sd">    Checks whether the sampling rate for outputs fits to chunksize and duration.</span>
<span class="sd">    Throws errors if not.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;State variable names not given.&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Initial value variable names not given.&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">),</span> <span class="s2">&quot;State variables are not same length as initial values.&quot;</span>

    <span class="c1"># throw a warning if the user is nasty</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span> <span class="o">%</span> <span class="n">chunksize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;It is strongly advised to use a `chunksize` (</span><span class="si">{</span><span class="n">chunksize</span><span class="si">}</span><span class="s2">) that is a divisor of `duration / dt` (</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>

    <span class="c1"># if `sampling_dt` is set, do some checks</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># sample_dt checks are required after setting chunksize</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;`chunksize * dt` must be &gt;= `sampling_dt`&quot;</span>

        <span class="c1"># ugly floating point modulo hack: instead of float1%float2==0, we do</span>
        <span class="c1"># (float1/float2)%1==0</span>
        <span class="k">assert</span> <span class="p">((</span><span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Chunksize </span><span class="si">{</span><span class="n">chunksize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> must be divisible by sampling dt &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Last chunk of size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">chunksize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> must be divisible by sampling dt &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.clearModelState">
<code class="highlight language-python"><span class="n">clearModelState</span><span class="p">()</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Clears the model's state to create a fresh one</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">clearModelState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clears the model&#39;s state to create a fresh one&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
    <span class="c1"># reinitialize bold model</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeBold</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.getMaxDelay">
<code class="highlight language-python"><span class="n">getMaxDelay</span><span class="p">()</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the maximum delay of the model. This function should be overloaded
if the model has internal delays (additional to delay between nodes defined by Dmat)
such as the delay between an excitatory and inhibitory population within each brain area.
If this function is not overloaded, the maximum delay is assumed to be defined from the
global delay matrix <code>Dmat</code>.</p>
<p>Note: Maxmimum delay is given in units of dt.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>int</code>
          </td>
          <td><p>maxmimum delay of the model in units of dt</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getMaxDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the maximum delay of the model. This function should be overloaded</span>
<span class="sd">    if the model has internal delays (additional to delay between nodes defined by Dmat)</span>
<span class="sd">    such as the delay between an excitatory and inhibitory population within each brain area.</span>
<span class="sd">    If this function is not overloaded, the maximum delay is assumed to be defined from the</span>
<span class="sd">    global delay matrix `Dmat`.</span>

<span class="sd">    Note: Maxmimum delay is given in units of dt.</span>

<span class="sd">    :return: maxmimum delay of the model in units of dt</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">)</span>
    <span class="n">Dmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lengthMat&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Dmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># divide Dmat by signalV</span>
        <span class="n">signalV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;signalV&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">signalV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Dmat</span> <span class="o">=</span> <span class="n">Dmat</span> <span class="o">/</span> <span class="n">signalV</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if signalV is 0, eliminate delays</span>
            <span class="n">Dmat</span> <span class="o">=</span> <span class="n">Dmat</span> <span class="o">*</span> <span class="mf">0.0</span>

    <span class="c1"># only if Dmat and dt exist, a global max delay can be computed</span>
    <span class="k">if</span> <span class="n">Dmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Dmat_ndt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">Dmat</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># delay matrix in multiples of dt</span>
        <span class="n">max_global_delay</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">Dmat_ndt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_global_delay</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">max_global_delay</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.getOutput">
<code class="highlight language-python"><span class="n">getOutput</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Get an output of a given name (dot.semarated)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>A key, grouped outputs in the form group.subgroup.variable</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>Output data</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get an output of a given name (dot.semarated)</span>
<span class="sd">    :param name: A key, grouped outputs in the form group.subgroup.variable</span>
<span class="sd">    :type name: str</span>

<span class="sd">    :returns: Output data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Output name must be a string.&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="n">lastOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lastOutput</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not found in outputs.&quot;</span>
        <span class="n">lastOutput</span> <span class="o">=</span> <span class="n">lastOutput</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lastOutput</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.getOutputs">
<code class="highlight language-python"><span class="n">getOutputs</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Get all outputs of an output group. Examples: <code>getOutputs("BOLD")</code> or simply <code>getOutputs()</code></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>group</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>Group name, subgroups separated by dots. If left empty (default), all outputs of the root group are returned.</p></td>
          <td>
                <code>&#39;&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getOutputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get all outputs of an output group. Examples: `getOutputs(&quot;BOLD&quot;)` or simply `getOutputs()`</span>

<span class="sd">    :param group: Group name, subgroups separated by dots. If left empty (default), all outputs of the root group</span>
<span class="sd">        are returned.</span>
<span class="sd">    :type group: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Group name must be a string.&quot;</span>

    <span class="k">def</span> <span class="nf">filterOutputsFromGroupDict</span><span class="p">(</span><span class="n">groupDict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary with the output data of a group disregarding all other nested dicts.</span>
<span class="sd">        :param groupDict: Dictionary of outputs (can include other groups)</span>
<span class="sd">        :type groupDict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Not a dictionary.&quot;</span>
        <span class="c1"># make a deep copy of the dictionary</span>
        <span class="n">returnDict</span> <span class="o">=</span> <span class="n">groupDict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">groupDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">returnDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">returnDict</span>

    <span class="c1"># if a group deeper than the root is given, select the last node</span>
    <span class="n">lastOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lastOutput</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not found in outputs.&quot;</span>
            <span class="n">lastOutput</span> <span class="o">=</span> <span class="n">lastOutput</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lastOutput</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> does not refer to a group.&quot;</span>
    <span class="c1"># filter out all output *groups* that might be in this node and return only output data</span>
    <span class="k">return</span> <span class="n">filterOutputsFromGroupDict</span><span class="p">(</span><span class="n">lastOutput</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.initializeBold">
<code class="highlight language-python"><span class="n">initializeBold</span><span class="p">()</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Initialize BOLD model.</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">initializeBold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize BOLD model.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># function to transform model state before passing it to the bold model</span>
    <span class="c1"># Note: This can be used like the parameter \epsilon in Friston2000</span>
    <span class="c1"># (neural efficacy) by multiplying the input with a constant via</span>
    <span class="c1"># self.boldInputTransform = lambda x: x * epsilon</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;boldInputTransform&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span> <span class="o">=</span> <span class="n">bold</span><span class="o">.</span><span class="n">BOLDModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.initializeRun">
<code class="highlight language-python"><span class="n">initializeRun</span><span class="p">(</span><span class="n">initializeBold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Initialization before each run.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>initializeBold</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>initialize BOLD model</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">initializeRun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initializeBold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization before each run.</span>

<span class="sd">    :param initializeBold: initialize BOLD model</span>
<span class="sd">    :type initializeBold: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the maxDelay of the system</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">maxDelay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxDelay</span><span class="p">()</span>

    <span class="c1"># length of the initial condition</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDelay</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># check dt / sampling_dt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setSamplingDt</span><span class="p">()</span>

    <span class="c1"># force bold if params[&#39;bold&#39;] == True</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
        <span class="n">initializeBold</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># set up the bold model, if it didn&#39;t happen yet</span>
    <span class="k">if</span> <span class="n">initializeBold</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeBold</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.integrate">
<code class="highlight language-python"><span class="n">integrate</span><span class="p">(</span><span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Calls each models <code>integration</code> function and saves the state and the outputs of the model.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>append</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calls each models `integration` function and saves the state and the outputs of the model.</span>

<span class="sd">    :param append: append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</span>
<span class="sd">    :type append: bool, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># run integration</span>
    <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">storeOutputsAndStates</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">)</span>

    <span class="c1"># force bold if params[&#39;bold&#39;] == True</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">):</span>
        <span class="n">simulate_bold</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># bold simulation after integration</span>
    <span class="k">if</span> <span class="n">simulate_bold</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulateBold</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.integrateChunkwise">
<code class="highlight language-python"><span class="n">integrateChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Repeatedly calls the chunkwise integration for the whole duration of the simulation.
If <code>bold==True</code>, the BOLD model is simulated after each chunk.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>chunksize</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>size of each chunk to simulate in units of dt</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>bold</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>simulate BOLD model after each chunk, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>append_outputs</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>append the chunkwise outputs to the outputs attribute, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">integrateChunkwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Repeatedly calls the chunkwise integration for the whole duration of the simulation.</span>
<span class="sd">    If `bold==True`, the BOLD model is simulated after each chunk.</span>

<span class="sd">    :param chunksize: size of each chunk to simulate in units of dt</span>
<span class="sd">    :type chunksize: int</span>
<span class="sd">    :param bold: simulate BOLD model after each chunk, defaults to False</span>
<span class="sd">    :type bold: bool, optional</span>
<span class="sd">    :param append_outputs: append the chunkwise outputs to the outputs attribute, defaults to False</span>
<span class="sd">    :type append_outputs: bool, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">totalDuration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
    <span class="c1"># create a shallow copy of the parameters</span>
    <span class="n">lastT</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">totalDuration</span> <span class="o">-</span> <span class="n">lastT</span> <span class="o">&gt;=</span> <span class="n">dt</span> <span class="o">-</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="c1"># Determine the size of the next chunk</span>
        <span class="c1"># account for floating point errors</span>
        <span class="n">remainingChunkSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">totalDuration</span> <span class="o">-</span> <span class="n">lastT</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">currentChunkSize</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">remainingChunkSize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autochunk</span><span class="p">(</span><span class="n">chunksize</span><span class="o">=</span><span class="n">currentChunkSize</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="n">append_outputs</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>
        <span class="c1"># we save the last simulated time step</span>
        <span class="n">lastT</span> <span class="o">+=</span> <span class="n">currentChunkSize</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="c1"># or</span>
        <span class="c1"># lastT = self.state[&quot;t&quot;][-1]</span>

    <span class="c1"># set duration back to its original value</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalDuration</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.randomICs">
<code class="highlight language-python"><span class="n">randomICs</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Generates a new set of uniformly-distributed random initial conditions for the model.</p>
<p>TODO: All parameters are drawn from the same distribution / range. Allow for independent ranges.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>min</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Minium of uniform distribution</p></td>
          <td>
                <code>0</code>
          </td>
        </tr>
        <tr>
          <td><code>max</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Maximum of uniform distribution</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">randomICs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a new set of uniformly-distributed random initial conditions for the model.</span>

<span class="sd">    TODO: All parameters are drawn from the same distribution / range. Allow for independent ranges.</span>

<span class="sd">    :param min: Minium of uniform distribution</span>
<span class="sd">    :type min: float</span>
<span class="sd">    :param max: Maximum of uniform distribution</span>
<span class="sd">    :type max: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.run">
<code class="highlight language-python"><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Main interfacing function to run a model.</p>
<p>The model can be run in three different ways:
1) <code>model.run()</code> starts a new run.
2) <code>model.run(chunkwise=True)</code> runs the simulation in chunks of length <code>chunksize</code>.
3) <code>mode.run(continue_run=True)</code> continues the simulation of a previous run.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code>list[np.ndarray|]</code>
          </td>
          <td><p>list of inputs to the model, must have the same order as model.input_vars. Note: no sanity check is performed for performance reasons. Take care of the inputs yourself.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>chunkwise</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>simulate model chunkwise or in one single run, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>chunksize</code></td>
          <td>
                <code>int, optional</code>
          </td>
          <td><p>size of the chunk to simulate in dt, if set will imply chunkwise=True, defaults to 2s</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>bold</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>simulate BOLD signal (only for chunkwise integration), defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>append</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>continue_run</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>continue a simulation by using the initial values from a previous simulation</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">chunkwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">append_outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continue_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main interfacing function to run a model.</span>

<span class="sd">    The model can be run in three different ways:</span>
<span class="sd">    1) `model.run()` starts a new run.</span>
<span class="sd">    2) `model.run(chunkwise=True)` runs the simulation in chunks of length `chunksize`.</span>
<span class="sd">    3) `mode.run(continue_run=True)` continues the simulation of a previous run.</span>

<span class="sd">    :param inputs: list of inputs to the model, must have the same order as model.input_vars. Note: no sanity check is performed for performance reasons. Take care of the inputs yourself.</span>
<span class="sd">    :type inputs: list[np.ndarray|]</span>
<span class="sd">    :param chunkwise: simulate model chunkwise or in one single run, defaults to False</span>
<span class="sd">    :type chunkwise: bool, optional</span>
<span class="sd">    :param chunksize: size of the chunk to simulate in dt, if set will imply chunkwise=True, defaults to 2s</span>
<span class="sd">    :type chunksize: int, optional</span>
<span class="sd">    :param bold: simulate BOLD signal (only for chunkwise integration), defaults to False</span>
<span class="sd">    :type bold: bool, optional</span>
<span class="sd">    :param append: append the chunkwise outputs to the outputs attribute, defaults to False, defaults to False</span>
<span class="sd">    :type append: bool, optional</span>
<span class="sd">    :param continue_run: continue a simulation by using the initial values from a previous simulation</span>
<span class="sd">    :type continue_run: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: legacy argument support</span>
    <span class="k">if</span> <span class="n">append_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">append_outputs</span>

    <span class="c1"># if a previous run is not to be continued clear the model&#39;s state</span>
    <span class="k">if</span> <span class="n">continue_run</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearModelState</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initializeRun</span><span class="p">(</span><span class="n">initializeBold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>

    <span class="c1"># enable chunkwise if chunksize is set</span>
    <span class="n">chunkwise</span> <span class="o">=</span> <span class="n">chunkwise</span> <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">chunkwise</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">append_outputs</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">simulate_bold</span><span class="o">=</span><span class="n">bold</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">continue_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setInitialValuesToLastState</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>

        <span class="c1"># check if model is safe for chunkwise integration</span>
        <span class="c1"># and whether sampling_dt is compatible with duration and chunksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bold</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: BOLD model not initialized, not simulating BOLD. Use `run(bold=True)`&quot;</span><span class="p">)</span>
            <span class="n">bold</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrateChunkwise</span><span class="p">(</span><span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="n">bold</span><span class="p">,</span> <span class="n">append_outputs</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>

    <span class="c1"># check if there was a problem with the simulated data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">checkOutputs</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.setInitialValuesToLastState">
<code class="highlight language-python"><span class="n">setInitialValuesToLastState</span><span class="p">()</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Reads the last state of the model and sets the initial conditions to that state for continuing a simulation.</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setInitialValuesToLastState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reads the last state of the model and sets the initial conditions to that state for continuing a simulation.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">):</span>
        <span class="c1"># if state variables are one-dimensional (in space only)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span>
        <span class="c1"># if they are space-time arrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we set the next initial condition to the last state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">sv</span><span class="p">][:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.setInputs">
<code class="highlight language-python"><span class="n">setInputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Take inputs from a list and store it in the appropriate model parameter for external input.
TODO: This is not safe yet, checks should be implemented whether the model has inputs defined or not for example.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code>list[np.ndarray(), ...]</code>
          </td>
          <td><p>list of inputs</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setInputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take inputs from a list and store it in the appropriate model parameter for external input.</span>
<span class="sd">    TODO: This is not safe yet, checks should be implemented whether the model has inputs defined or not for example.</span>

<span class="sd">    :param inputs: list of inputs</span>
<span class="sd">    :type inputs: list[np.ndarray(), ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.setOutput">
<code class="highlight language-python"><span class="n">setOutput</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Adds an output to the model, typically a simulation result.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>Name of the output in dot.notation, a la "outputgroup.output"</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>data</code></td>
          <td>
                <code>`numpy.ndarray`</code>
          </td>
          <td><p>Output data, can't be a dictionary!</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds an output to the model, typically a simulation result.</span>
<span class="sd">    :params name: Name of the output in dot.notation, a la &quot;outputgroup.output&quot;</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :params data: Output data, can&#39;t be a dictionary!</span>
<span class="sd">    :type data: `numpy.ndarray`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Output data cannot be a dictionary.&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Output name must be a string.&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;Output must be a `numpy.ndarray`.&quot;</span>

    <span class="c1"># remove initial conditions from output</span>
    <span class="k">if</span> <span class="n">removeICs</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to truncate data of shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># subsample to sampling dt</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">::</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to subsample data of shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># if the output is a single name (not dot.separated)</span>
    <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="c1"># append data</span>
        <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="c1"># special treatment for time data:</span>
            <span class="c1"># increment the time by the last recorded duration</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># save all data into output dict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># set output as an attribute</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># build results dictionary and write into self.outputs</span>
        <span class="c1"># dot.notation iteration</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>  <span class="c1"># not copy, reference!</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="c1"># if it&#39;s the last iteration, store data</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># TODO: this needs to be append-aware like above</span>
                <span class="c1"># if append:</span>
                <span class="c1">#     if k == &quot;t&quot;:</span>
                <span class="c1">#         data += level[k][-1]</span>
                <span class="c1">#     level[k] = np.hstack((level[k], data))</span>
                <span class="c1"># else:</span>
                <span class="c1">#     level[k] = data</span>
                <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="c1"># if key is in outputs, then go deeper</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
            <span class="c1"># if it&#39;s a new key, create new nested dictionary, set attribute, then go deeper</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dotdict</span><span class="p">({})</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.setSamplingDt">
<code class="highlight language-python"><span class="n">setSamplingDt</span><span class="p">()</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Checks if sampling_dt is set correctly and sets self.<code>sample_every</code>
1) Check if sampling_dt is multiple of dt
2) Check if semplind_dt is greater than duration</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setSamplingDt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks if sampling_dt is set correctly and sets self.`sample_every`</span>
<span class="sd">    1) Check if sampling_dt is multiple of dt</span>
<span class="sd">    2) Check if semplind_dt is greater than duration</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="s2">&quot;`sampling_dt` needs to be &gt;= `dt`&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;`sampling_dt` needs to be lower than `duration`&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sampling_dt&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t handle `sampling_dt`=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sampling_dt&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.setStateVariables">
<code class="highlight language-python"><span class="n">setStateVariables</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Saves the models current state variables.</p>
<p>TODO: Cut state variables to length of self.maxDelay
However, this could be time-memory tradeoff</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>name of the state variable</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>data</code></td>
          <td>
                <code>np.ndarray</code>
          </td>
          <td><p>value of the variable</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setStateVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Saves the models current state variables.</span>

<span class="sd">    TODO: Cut state variables to length of self.maxDelay</span>
<span class="sd">    However, this could be time-memory tradeoff</span>

<span class="sd">    :param name: name of the state variable</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param data: value of the variable</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># old</span>
    <span class="c1"># self.state[name] = data.copy()</span>

    <span class="c1"># if the data is temporal, cut off initial values</span>
    <span class="c1"># NOTE: this shuold actually check for</span>
    <span class="c1"># if data.shape[1] &gt; 1:</span>
    <span class="c1"># else: data.copy()</span>
    <span class="c1"># there coulb be (N, 1)-dimensional output, right now</span>
    <span class="c1"># it is requred to be of shape (N, )</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.simulateBold">
<code class="highlight language-python"><span class="n">simulateBold</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Gets the default output of the model and simulates the BOLD model.
Adds the simulated BOLD signal to outputs.</p>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">simulateBold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gets the default output of the model and simulates the BOLD model.</span>
<span class="sd">    Adds the simulated BOLD signal to outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInitialized</span><span class="p">:</span>
        <span class="c1"># first we loop through all state variables</span>
        <span class="k">for</span> <span class="n">svn</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
            <span class="c1"># the default output is used as the input for the bold model</span>
            <span class="k">if</span> <span class="n">svn</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_output</span><span class="p">:</span>
                <span class="n">bold_input</span> <span class="o">=</span> <span class="n">sv</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">startindt</span> <span class="p">:]</span>
                <span class="c1"># logging.debug(f&quot;BOLD input `{svn}` of shape {bold_input.shape}&quot;)</span>
                <span class="k">if</span> <span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="p">:</span>
                    <span class="c1"># only if the length of the output has a zero mod to the sampling rate,</span>
                    <span class="c1"># the downsampled output from the boldModel can correctly appended to previous data</span>
                    <span class="c1"># so: we are lazy here and simply disable appending in that case ...</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Output size </span><span class="si">{</span><span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a multiple of BOLD sampling length </span><span class="si">{</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="si">}</span><span class="s2">, will not append data.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulating BOLD: boldModel.run(append=</span><span class="si">{</span><span class="n">append</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                    <span class="c1"># transform bold input according to self.boldInputTransform</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span><span class="p">:</span>
                        <span class="n">bold_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldInputTransform</span><span class="p">(</span><span class="n">bold_input</span><span class="p">)</span>

                    <span class="c1"># simulate bold model</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">bold_input</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>

                    <span class="n">t_BOLD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">t_BOLD</span>
                    <span class="n">BOLD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">BOLD</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;BOLD.t_BOLD&quot;</span><span class="p">,</span> <span class="n">t_BOLD</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;BOLD.BOLD&quot;</span><span class="p">,</span> <span class="n">BOLD</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Will not simulate BOLD if output </span><span class="si">{</span><span class="n">bold_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> not at least of duration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">boldModel</span><span class="o">.</span><span class="n">samplingRate_NDt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;BOLD model not initialized, not simulating BOLD. Use `run(bold=True)`&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.storeOutputsAndStates">
<code class="highlight language-python"><span class="n">storeOutputsAndStates</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Takes the simulated variables of the integration and stores it to the appropriate model output and state object.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>t</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>time vector</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>variables</code></td>
          <td>
                <code>numpy.ndarray</code>
          </td>
          <td><p>variable from time integration</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>append</code></td>
          <td>
                <code>bool, optional</code>
          </td>
          <td><p>append output to existing output or overwrite, defaults to False</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">storeOutputsAndStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes the simulated variables of the integration and stores it to the appropriate model output and state object.</span>

<span class="sd">    :param t: time vector</span>
<span class="sd">    :type t: list</span>
<span class="sd">    :param variables: variable from time integration</span>
<span class="sd">    :type variables: numpy.ndarray</span>
<span class="sd">    :param append: append output to existing output or overwrite, defaults to False</span>
<span class="sd">    :type append: bool, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># save time array</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setStateVariables</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="c1"># save outputs</span>
    <span class="k">for</span> <span class="n">svn</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_vars</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">svn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">svn</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">removeICs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setStateVariables</span><span class="p">(</span><span class="n">svn</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="neurolib.models.model.Model.xr">
<code class="highlight language-python"><span class="n">xr</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Converts a group of outputs to xarray. Output group needs to contain an
element that starts with the letter "t" or it will not recognize any time axis.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>group</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>Output group name, example:  "BOLD". Leave empty for top group.</p></td>
          <td>
                <code>&#39;&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>neurolib/models/model.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">xr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts a group of outputs to xarray. Output group needs to contain an</span>
<span class="sd">    element that starts with the letter &quot;t&quot; or it will not recognize any time axis.</span>

<span class="sd">    :param group: Output group name, example:  &quot;BOLD&quot;. Leave empty for top group.</span>
<span class="sd">    :type group: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Group name must be a string.&quot;</span>
    <span class="c1"># take all outputs of one group: disregard all dictionaries because they are subgroups</span>
    <span class="n">outputDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutputs</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    <span class="c1"># make sure that there is a time array</span>
    <span class="n">timeDictKey</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="p">:</span>
        <span class="n">timeDictKey</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">):</span>
                <span class="n">timeDictKey</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assuming </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> to be the time axis.&quot;</span><span class="p">)</span>
                <span class="k">break</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">timeDictKey</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;No time array found (starting with t) in output group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">outputDict</span><span class="p">[</span><span class="n">timeDictKey</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">outputDict</span><span class="p">[</span><span class="n">timeDictKey</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">outputNames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">outputDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">outputNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">nNodes</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nNodes</span><span class="p">))</span>
    <span class="n">allOutputsStacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>  <span class="c1"># What? Where? When?</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">allOutputsStacked</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">outputNames</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="s2">&quot;space&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
        <div class="md-social">
  
    
    
    <a href="https://twitter.com/neurolib-dev" target="_blank" rel="noopener" title="neurolib on Twitter" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.e5c33ebb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.51d95adb.min.js"></script>
      
        <script src="../../js/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>